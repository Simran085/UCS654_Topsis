# -*- coding: utf-8 -*-
"""102216115.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CRphvnm-C7l8ljLuKTu678-vkK3lAngF
"""

import sys
import numpy as np
import pandas as pd
from math import sqrt, inf
import numbers

def normalize_data(data):
    norm_data = data.iloc[:, 1:].apply(lambda x: x / np.sqrt((x**2).sum()), axis=0)
    norm_data.insert(0, data.columns[0], data.iloc[:, 0])
    print("\nNormalized Decision Matrix:\n", norm_data)
    return norm_data

def apply_weights(norm_data, weights):
    weighted_data = norm_data.copy()
    weighted_data.iloc[:, 1:] = weighted_data.iloc[:, 1:] * weights
    print("\nWeighted Normalized Decision Matrix:\n", weighted_data)
    return weighted_data

def calculate_ideal_solutions(weighted_data, impacts):
    ideal_best = weighted_data.iloc[:, 1:].apply(
        lambda x: x.max() if impacts[weighted_data.columns.get_loc(x.name)-1] == '+' else x.min()
    )
    ideal_worst = weighted_data.iloc[:, 1:].apply(
        lambda x: x.min() if impacts[weighted_data.columns.get_loc(x.name)-1] == '+' else x.max()
    )
    print("\nIdeal Best:", ideal_best.tolist())
    print("Ideal Worst:", ideal_worst.tolist())
    return ideal_best, ideal_worst


def compute_distances(weighted_data, ideal_best, ideal_worst):
    dist_best = np.sqrt(((weighted_data.iloc[:, 1:] - ideal_best) ** 2).sum(axis=1))
    dist_worst = np.sqrt(((weighted_data.iloc[:, 1:] - ideal_worst) ** 2).sum(axis=1))
    print("\nDistance to Ideal Best:", dist_best.tolist())
    print("Distance to Ideal Worst:", dist_worst.tolist())
    return dist_best, dist_worst

def topsis(data, weights, impacts, output_file):
    norm_data = normalize_data(data)
    weighted_data = apply_weights(norm_data, weights)
    ideal_best, ideal_worst = calculate_ideal_solutions(weighted_data, impacts)
    dist_best, dist_worst = compute_distances(weighted_data, ideal_best, ideal_worst)

    data['Topsis Score'] = dist_worst / (dist_best + dist_worst)
    data['Rank'] = data['Topsis Score'].rank(method='max', ascending=False)
    print("\nFinal Result with Topsis Score and Rank:\n", data)
    data.to_csv(output_file, index=False)
    print(f"\nResults saved to {output_file}")

def validate_inputs(file_path, weights, impacts, output_file):
    if not file_path.endswith('.csv') or not output_file.endswith('.csv'):
        sys.exit("Input and output files must be CSV.")

    try:
        data = pd.read_csv(file_path)
    except FileNotFoundError:
        sys.exit("Input file not found.")
    
    if data.shape[1] < 3:
        sys.exit("Input file must contain at least three columns.")
    
    if any(not pd.api.types.is_numeric_dtype(data.iloc[:, i]) for i in range(1, data.shape[1])):
        sys.exit("All criteria columns must be numeric.")
    
    weights = [float(w) for w in weights.split(',')]
    impacts = impacts.split(',')
    
    if len(weights) != data.shape[1] - 1 or len(impacts) != data.shape[1] - 1:
        sys.exit("Weights and impacts must match the number of criteria.")
    
    if not set(impacts).issubset({'+', '-'}):
        sys.exit("Impacts must be '+' or '-'.")
    
    return data, weights, impacts

def main():
    if len(sys.argv) != 5:
        sys.exit("Usage: python script.py <input.csv> <weights> <impacts> <output.csv>")
    
    input_file, weights, impacts, output_file = sys.argv[1:5]
    data, weights, impacts = validate_inputs(input_file, weights, impacts, output_file)
    topsis(data, weights, impacts, output_file)

if __name__ == "__main__":
    main()
